

Magic Lantern Nightly.2021Mar26.50D109
Camera   : 50D
Firmware : 109
Changeset: 352a05ff20db+ (qemu)
Built on : 2021-03-26 11:39:07 by david@david-VirtualBox

diff -r 352a05ff20db src/imath.c
--- a/src/imath.c	Wed Mar 24 17:35:08 2021 +0000
+++ b/src/imath.c	Fri Mar 26 12:39:07 2021 +0100
@@ -3,36 +3,39 @@
 #include "dryos.h"
 #include "math.h"
 
-int powi(int base, int power)
-{
+int powi(int base, int power) {
     int result = 1;
-    while (power)
-    {
-        if (power & 1)
+    while (power) {
+        if (power & 1) {
             result *= base;
+        }
         power >>= 1;
         base *= base;
     }
     return result;
 }
 
-int log2i(int x)
-{
+int log2i(int x) {
     int result = 0;
-    while (x >>= 1) result++;
+    while (x >>= 1) {
+    	result++;
+    }
     return result;
 }
 
-int log10i(int x)
-{
+int log10i(int x) {
     int result = 0;
-    while(x /= 10) result++;
+    while(x /= 10) { 
+    	result++;
+    }
     return result;
 }
 
 /* todo: integer-only implementation? */
-uint32_t log_length(int v)
-{
-    if (!v) return 0;
-    return (unsigned int)(log2f(v) * 100);
+uint32_t log_length(int v) {
+	uint32_t value = 0; 
+    if (v) {
+    	value = ((unsigned int)(log2f(v) * 100));
+    }
+    return value;
 }
diff -r 352a05ff20db src/module.h
--- a/src/module.h	Wed Mar 24 17:35:08 2021 +0000
+++ b/src/module.h	Fri Mar 26 12:39:07 2021 +0100
@@ -340,8 +340,10 @@
 /* see propvalues.c */
 extern int is_camera(const char * model, const char * firmware);
 
+/* esto fue comentado
 #ifdef MODULE
-#include "module_strings.h"
+	#include "module_strings.h" 
 #endif
+*/
 
 #endif
diff -r 352a05ff20db src/zebra.c
--- a/src/zebra.c	Wed Mar 24 17:35:08 2021 +0000
+++ b/src/zebra.c	Fri Mar 26 12:39:07 2021 +0100
@@ -3698,75 +3698,90 @@
     return 0;
 }
 
-void draw_histogram_and_waveform(int allow_play)
-{
-
-    if (menu_active_and_not_hidden()) return;
-    if (!get_global_draw()) return;
+void draw_histogram_and_waveform(int allow_play) {
+
+    if (menu_active_and_not_hidden()) {
+    	return;
+    }
+    if (!get_global_draw()) {
+    	return;
+    }
 
     get_yuv422_vram();
 
 #if defined(FEATURE_HISTOGRAM) || defined(FEATURE_WAVEFORM) || defined(FEATURE_VECTORSCOPE)
-    if (0
-        || hist_draw
-        || waveform_draw
-#if defined(FEATURE_VECTORSCOPE)
-        || vectorscope_should_draw()
-#endif
-        )
-    {
+    if (0 || hist_draw || waveform_draw 
+	#if defined(FEATURE_VECTORSCOPE)
+		|| vectorscope_should_draw()
+	#endif
+    ) {
         hist_build(); /* also updates waveform and vectorscope */
     }
 #endif
     
-    if (menu_active_and_not_hidden()) return; // hack: not to draw histo over menu
-    if (!get_global_draw()) return;
-    if (!liveview_display_idle() && !(PLAY_OR_QR_MODE && allow_play) && !gui_menu_shown()) return;
-    if (is_zoom_mode_so_no_zebras()) return;
+    if (menu_active_and_not_hidden()) {
+    	return; // hack: not to draw histo over menu
+    }
+    if (!get_global_draw()) {
+    	return;
+    }
+    if (!liveview_display_idle() && !(PLAY_OR_QR_MODE && allow_play) && !gui_menu_shown()) {
+    	return;
+    }
+    if (is_zoom_mode_so_no_zebras()) {
+    	return;
+    }
 
     int screen_layout = get_screen_layout();
 
 #ifdef FEATURE_HISTOGRAM
-    if( hist_draw && !WAVEFORM_FULLSCREEN)
-    {
+    if( hist_draw && !WAVEFORM_FULLSCREEN) {
         #ifdef CONFIG_4_3_SCREEN
-        if (PLAY_OR_QR_MODE)
-            BMP_LOCK( hist_draw_image( os.x0 + 500,  1); )
-        else
+		    if (PLAY_OR_QR_MODE) {
+		        BMP_LOCK( hist_draw_image( os.x0 + 500,  1); )
+		    } else
         #endif
-        if (should_draw_bottom_graphs())
+        if (should_draw_bottom_graphs()) {
             BMP_LOCK( hist_draw_image( os.x0 + 50,  480 - hist_height - 1); )
-        else if (screen_layout == SCREENLAYOUT_3_2)
+        } else if (screen_layout == SCREENLAYOUT_3_2) {
             BMP_LOCK( hist_draw_image( os.x_max - HIST_WIDTH - 2,  os.y_max - (lv ? os.off_169 + 10 : 0) - hist_height - 1); )
-        else
+        } else {
             BMP_LOCK( hist_draw_image( os.x_max - HIST_WIDTH - 5, os.y0 + 100); )
+        }
     }
 #endif
 
-    if (menu_active_and_not_hidden()) return;
-    if (!get_global_draw()) return;
-    if (!liveview_display_idle() && !(PLAY_OR_QR_MODE && allow_play) && !gui_menu_shown()) return;
-    if (is_zoom_mode_so_no_zebras()) return;
+    if (menu_active_and_not_hidden()) {
+    	return;
+    }
+    if (!get_global_draw()) {
+    	return;
+    }
+    if (!liveview_display_idle() && !(PLAY_OR_QR_MODE && allow_play) && !gui_menu_shown()) {
+    	return;
+    }
+    if (is_zoom_mode_so_no_zebras()) {
+    	return;
+    }
         
 #ifdef FEATURE_WAVEFORM
-    if( waveform_draw)
-    {
+    if( waveform_draw) {
         #ifdef CONFIG_4_3_SCREEN
-        if (PLAY_OR_QR_MODE && WAVEFORM_FACTOR == 1)
-            BMP_LOCK( waveform_draw_image( os.x0 + 100,  1, 54); )
-        else
+		    if (PLAY_OR_QR_MODE && WAVEFORM_FACTOR == 1) {
+		        BMP_LOCK( waveform_draw_image( os.x0 + 100,  1, 54); )
+		    } else
         #endif
-        if (should_draw_bottom_graphs() && WAVEFORM_FACTOR == 1)
+        if (should_draw_bottom_graphs() && WAVEFORM_FACTOR == 1) {
             BMP_LOCK( waveform_draw_image( os.x0 + 250,  480 - 54, 54); )
-        else if (screen_layout == SCREENLAYOUT_3_2 && !WAVEFORM_FULLSCREEN)
-        {
-            if (WAVEFORM_FACTOR == 1)
+        } else if (screen_layout == SCREENLAYOUT_3_2 && !WAVEFORM_FULLSCREEN) {
+            if (WAVEFORM_FACTOR == 1) {
                 BMP_LOCK( waveform_draw_image( os.x0 + 4, os.y_max - (lv ? os.off_169 : 0) - (gui_menu_shown() ? 25 : 0) - 54, 54); )
-            else
+            } else {
                 BMP_LOCK( waveform_draw_image( os.x_max - WAVEFORM_WIDTH*WAVEFORM_FACTOR - 4, os.y0 + 100, WAVEFORM_HEIGHT*WAVEFORM_FACTOR ); );
+            }
+        } else {
+            BMP_LOCK( waveform_draw_image( os.x_max - WAVEFORM_WIDTH*WAVEFORM_FACTOR - (WAVEFORM_FULLSCREEN ? 0 : 4), os.y_max - WAVEFORM_HEIGHT*WAVEFORM_FACTOR - WAVEFORM_OFFSET, WAVEFORM_HEIGHT*WAVEFORM_FACTOR ); )
         }
-        else
-            BMP_LOCK( waveform_draw_image( os.x_max - WAVEFORM_WIDTH*WAVEFORM_FACTOR - (WAVEFORM_FULLSCREEN ? 0 : 4), os.y_max - WAVEFORM_HEIGHT*WAVEFORM_FACTOR - WAVEFORM_OFFSET, WAVEFORM_HEIGHT*WAVEFORM_FACTOR ); )
     }
 #endif
 
@@ -3776,79 +3791,78 @@
 }
 
 
-static void
-clearscreen_task( void* unused )
-{
+static void clearscreen_task( void* unused ) {
     idle_wakeup_reset_counters(0);
 
-    TASK_LOOP
-    {
-clearscreen_loop:
-        msleep(100);
-
-        //~ bmp_printf(FONT_MED, 100, 100, "%d %d %d", idle_countdown_display_dim, idle_countdown_display_off, idle_countdown_globaldraw);
-        
-        /* blink LED if screen is turned off */
-        idle_led_blink_step(k);
-
-        if (!lv && !lv_paused) continue;
-        
-        #ifdef FEATURE_CLEAR_OVERLAYS
-        if (clearscreen == 3)
-        {
-            if (liveview_display_idle() && !gui_menu_shown())
-            {
-                bmp_off();
-            }
-            else
-            {
-                bmp_on();
-            }
-        }
-        
-        if (clearscreen == 4)
-        {
-            if (RECORDING)
-            {
-                bmp_off();
-            }
-            else
-            {
-                bmp_on();
-            }
-        }
-
-        // clear overlays on shutter halfpress
-        if (clearscreen == 1 && (get_halfshutter_pressed() || dofpreview) && !gui_menu_shown())
-        {
-            BMP_LOCK( clrscr_mirror(); )
-            int i;
-            for (i = 0; i < (int)clearscreen_delay/20; i++)
-            {
-                if (i % 10 == 0 && liveview_display_idle()) BMP_LOCK( update_lens_display(1,1); )
-                msleep(20);
-                if (!(get_halfshutter_pressed() || dofpreview))
-                    goto clearscreen_loop;
-            }
-            bmp_off();
-            while ((get_halfshutter_pressed() || dofpreview)) msleep(100);
-            bmp_on();
-            #ifdef CONFIG_ZOOM_BTN_NOT_WORKING_WHILE_RECORDING
-            msleep(100);
-            if (get_zoom_overlay_trigger_by_halfshutter()) // this long press should not trigger MZ
-                zoom_overlay_toggle();
-            #endif
-        }
-        #endif
-        
-        #ifdef FEATURE_POWERSAVE_LIVEVIEW
-        idle_powersave_step();
-        #endif
-        
-        #ifdef FEATURE_CROPMARKS
-        // since this task runs at 10Hz, I prefer cropmark redrawing here
-        cropmark_step();
-        #endif
+    TASK_LOOP {
+		clearscreen_loop:
+		    msleep(100);
+
+		    //~ bmp_printf(FONT_MED, 100, 100, "%d %d %d", idle_countdown_display_dim, idle_countdown_display_off, idle_countdown_globaldraw);
+		    
+		    /* blink LED if screen is turned off */
+		    idle_led_blink_step(k);
+
+			/*
+		    if (!lv && !lv_paused) {
+		    	continue;
+		    }
+		    */
+		    
+		    #ifdef FEATURE_CLEAR_OVERLAYS
+		    	switch (clearscreen) {
+		    		case 3:
+		    			if (liveview_display_idle() && !gui_menu_shown()) {
+				        	bmp_off();
+						} else {
+						    bmp_on();
+						}
+		    			break;
+		    		
+		    		case 4:
+		    			if (RECORDING) {
+				        	bmp_off();
+						} else {
+						    bmp_on();
+						}
+		    			break;
+		    	}
+				
+				// clear overlays on shutter halfpress
+				if (clearscreen == 1 && (get_halfshutter_pressed() || dofpreview) && !gui_menu_shown()) {
+				    BMP_LOCK( clrscr_mirror(); );
+				    int i = 0;
+				    for (i = 0; i < (int)clearscreen_delay/20; i++) {
+				        if (i % 10 == 0 && liveview_display_idle()) {
+				        	BMP_LOCK( update_lens_display(1,1); );
+				        }
+				        msleep(20);
+				        if (!(get_halfshutter_pressed() || dofpreview)) {
+				            goto clearscreen_loop; //CUIDADO!
+				        }
+				    }
+				    bmp_off();
+				    while ((get_halfshutter_pressed() || dofpreview)) {
+				    	msleep(100);
+				    }
+				    bmp_on();
+				    #ifdef CONFIG_ZOOM_BTN_NOT_WORKING_WHILE_RECORDING
+						msleep(100);
+						if (get_zoom_overlay_trigger_by_halfshutter()) { // this long press should not trigger MZ
+						    zoom_overlay_toggle();
+						}
+				    #endif
+				}
+		    #endif
+		    
+		    #ifdef FEATURE_POWERSAVE_LIVEVIEW
+		    	idle_powersave_step();
+		    #endif
+		    
+		    #ifdef FEATURE_CROPMARKS
+				// since this task runs at 10Hz, I prefer cropmark redrawing here
+				cropmark_step();
+		    #endif
     }
 }
 
@@ -3860,26 +3874,29 @@
 // this should be synchronized with
 // * graphics code (like zebra); otherwise zebras will remain frozen on screen
 // * gui_main_task (to make sure Canon won't call redraw in parallel => crash)
-void _redraw_do()
-{
+void _redraw_do() {
     extern int ml_started;
-    if (!ml_started) return;
-    if (gui_menu_shown()) { menu_redraw(); return; }
+    /*
+    if (!ml_started) {
+    	return;
+    }
+    */
+    if (gui_menu_shown()) { 
+    	menu_redraw(); 
+    }
     
 BMP_LOCK (
 
-#ifdef CONFIG_VARIANGLE_DISPLAY
-    if (display_dont_mirror && display_dont_mirror_dirty)
-    {
-        if (lcd_position == 1)
-        {
-            /* Canon stub, usually available only on cameras with variable displays */
-            extern void NormalDisplay();
-            NormalDisplay();
-        }
-        display_dont_mirror_dirty = 0;
-    }
-#endif
+	#ifdef CONFIG_VARIANGLE_DISPLAY
+		if (display_dont_mirror && display_dont_mirror_dirty) {
+		    if (lcd_position == 1) {
+		        /* Canon stub, usually available only on cameras with variable displays */
+		        extern void NormalDisplay();
+		        NormalDisplay();
+		    }
+		    display_dont_mirror_dirty = 0;
+		}
+	#endif
 
     //~ if (disable_redraw) 
     //~ {
@@ -3890,41 +3907,37 @@
         struct gui_task * current = gui_task_list.current;
         struct dialog * dialog = current->priv;
 
-        if (dialog && streq(dialog->type, "DIALOG")) // if dialog seems valid
-        {
+        if (dialog && streq(dialog->type, "DIALOG")) { // if dialog seems valid
+        
             // to redraw, we need access to front buffer
             int front_buffer_disabled = canon_gui_front_buffer_disabled();
-            if (front_buffer_disabled)
-            {
+            if (front_buffer_disabled) {
                 /* temporarily enable front buffer to allow the redraw */
                 canon_gui_enable_front_buffer(0);
             }
             
             dialog_redraw(dialog); // try to redraw (this has semaphores for winsys)
             
-            if (front_buffer_disabled)
-            {
+            if (front_buffer_disabled) {
                 /* disable it back */
                 
                 #ifdef CONFIG_KILL_FLICKER
-                idle_kill_flicker();
+                	idle_kill_flicker();
                 #else
-                canon_gui_disable_front_buffer();
+                	canon_gui_disable_front_buffer();
                 #endif
             }
-        }
-        else
-        {
+        } else {
             clrscr(); // out of luck, fallback
         }
     }
-)
+);
 
     // ask other stuff to redraw
     afframe_set_dirty();
 
     #ifdef FEATURE_CROPMARKS
-    crop_set_dirty(cropmark_cache_is_valid() ? 2 : 10);
+    	crop_set_dirty(cropmark_cache_is_valid() ? 2 : 10);
     #endif
     
     menu_set_dirty();
@@ -3932,112 +3945,105 @@
     zoom_overlay_dirty = 1;
 }
 
-void redraw()
-{
+void redraw() {
     fake_simple_button(MLEV_REDRAW);
 }
 
 #ifdef FEATURE_GHOST_IMAGE
-static int transparent_overlay_flag = 0;
-void schedule_transparent_overlay()
-{
-    transparent_overlay_flag = 1;
-}
+	static int transparent_overlay_flag = 0;
+	void schedule_transparent_overlay() {
+		transparent_overlay_flag = 1;
+	}
 #endif
 
 static int lens_display_dirty = 0;
-void lens_display_set_dirty() 
-{ 
+void lens_display_set_dirty() { 
     lens_display_dirty = 4; 
-    if (menu_active_but_hidden()) // in this case, menu will display bottom bar, force a redraw
+    if (menu_active_but_hidden()) { // in this case, menu will display bottom bar, force a redraw
         menu_set_dirty(); 
+    }
 }
 
-int is_focus_peaking_enabled()
-{
-#ifdef FEATURE_FOCUS_PEAK
-    return
-        focus_peaking &&
-        (lv || (QR_MODE && ZEBRAS_IN_QUICKREVIEW))
-        && get_global_draw()
-        && !should_draw_zoom_overlay()
-    ;
-#else
-    return 0;
-#endif
+int is_focus_peaking_enabled() {
+	int value = 0;
+	#ifdef FEATURE_FOCUS_PEAK
+		value = (focus_peaking && (lv || (QR_MODE && ZEBRAS_IN_QUICKREVIEW)) && get_global_draw() && !should_draw_zoom_overlay());		
+	#endif
+	return value;
 }
 
-static void digic_zebra_cleanup()
-{
-#ifdef FEATURE_ZEBRA_FAST
-    if (zebra_digic_dirty)
-    {
-        if (!DISPLAY_IS_ON) return;
-        EngDrvOut(DIGIC_ZEBRA_REGISTER, 0); 
-        clrscr_mirror();
-        alter_bitmap_palette_entry(FAST_ZEBRA_GRID_COLOR, FAST_ZEBRA_GRID_COLOR, 256, 256);
-        zebra_digic_dirty = 0;
-    }
-#endif
+static void digic_zebra_cleanup() {
+	#ifdef FEATURE_ZEBRA_FAST
+		if (zebra_digic_dirty && DISPLAY_IS_ON) {        
+			EngDrvOut(DIGIC_ZEBRA_REGISTER, 0); 
+			clrscr_mirror();
+			alter_bitmap_palette_entry(FAST_ZEBRA_GRID_COLOR, FAST_ZEBRA_GRID_COLOR, 256, 256);
+			zebra_digic_dirty = 0;        
+		}
+	#endif
 }
 
 #ifdef FEATURE_SHOW_OVERLAY_FPS
-void update_lv_fps() // to be called every 10 seconds
-{
-    if (show_lv_fps) bmp_printf(FONT_MED, 50, 50, "%d.%d fps ", fps_ticks/10, fps_ticks%10);
-    fps_ticks = 0;
-}
+	void update_lv_fps() { // to be called every 10 seconds
+		if (show_lv_fps) { 
+			bmp_printf(FONT_MED, 50, 50, "%d.%d fps ", fps_ticks/10, fps_ticks%10);
+		}
+		fps_ticks = 0;
+	}
 #endif
 
 // Items which need a high FPS
 // Magic Zoom, Focus Peaking, zebra*, spotmeter*, false color*
 // * = not really high FPS, but still fluent
- static void
-livev_hipriority_task( void* unused )
-{
+static void livev_hipriority_task( void* unused ) {
     msleep(1000);
     
     #ifdef FEATURE_CROPMARKS
-    find_cropmarks();
+    	find_cropmarks();
     #endif
     
     #ifdef FEATURE_LV_DISPLAY_PRESETS
-    update_disp_mode_bits_from_params();
+    	update_disp_mode_bits_from_params();
     #endif
     
-    TASK_LOOP
-    {
+    TASK_LOOP {
         //~ vsync(&YUV422_LV_BUFFER_DISPLAY_ADDR);
         fps_ticks++;
 
-        while (is_mvr_buffer_almost_full())
-        {
+        while (is_mvr_buffer_almost_full()) {
             msleep(100);
         }
 
         int zd = zebra_draw && (lv_luma_is_accurate() || PLAY_OR_QR_MODE) && (zebra_rec || NOT_RECORDING); // when to draw zebras (should match the one from draw_zebra_and_focus)
-        if (!zd) digic_zebra_cleanup();
+        if (!zd) {
+        	digic_zebra_cleanup();
+        }
         
-#ifdef CONFIG_RAW_LIVEVIEW
-        static int raw_flag = 0;
-#endif
+		#ifdef CONFIG_RAW_LIVEVIEW
+        	static int raw_flag = 0;
+		#endif
         
-        if (!zebra_should_run())
-        {
-            while (clearscreen == 1 && (get_halfshutter_pressed() || dofpreview)) msleep(100);
-            while (RECORDING_H264_STARTING) msleep(100);
-            if (!zebra_should_run())
-            {
+        if (!zebra_should_run()) {
+            while ((clearscreen == 1 && (get_halfshutter_pressed() || dofpreview)) || RECORDING_H264_STARTING) {
+            	msleep(100);
+            }            
+            if (!zebra_should_run()) {
                 digic_zebra_cleanup();
-                if (lv && !gui_menu_shown()) redraw();
+                if (lv && !gui_menu_shown()) {
+                	redraw();
+                }
                 #ifdef CONFIG_ELECTRONIC_LEVEL
-                if (lv) disable_electronic_level();
+                	if (lv) {
+                		disable_electronic_level();
+                	}
                 #endif
                 #ifdef CONFIG_RAW_LIVEVIEW
-                if (raw_flag) { raw_lv_release(); raw_flag = 0; }
+                	if (raw_flag) { 
+                		raw_lv_release(); 
+                		raw_flag = 0; 
+                	}
                 #endif
-                while (!zebra_should_run()) 
-                {
+                while (!zebra_should_run()) { //^
                     msleep(100);
                 }
                 vram_params_set_dirty();
@@ -4045,11 +4051,12 @@
                 crop_set_dirty(10);
                 msleep(500);
             }
-            if (!zebra_should_run())
-            {
-                /* false alarm */
+            /*
+            if (!zebra_should_run()) {
+                // false alarm 
                 continue;
             }
+            */
         }
         #if 0
         draw_cropmark_area(); // just for debugging
@@ -4059,30 +4066,28 @@
         #endif
 
         #ifdef CONFIG_RAW_LIVEVIEW
-        int raw_needed = 0;
-
-        /* if picture quality is raw, switch the LiveView to raw mode (photo, zoom 1x) */
-        int raw = pic_quality & 0x60000;
-        if (raw && lv_dispsize == 1 && !is_movie_mode())
-        {
-            /* only raw zebras, raw histogram and raw spotmeter are working in LV raw mode */
-            if (zebra_draw && raw_zebra_enable == 1) raw_needed = 1;        /* raw zebras: always */
-            if (hist_draw && RAW_HISTOGRAM_ENABLED) raw_needed = 1;          /* raw hisogram (any kind) */
-            if (spotmeter_draw && spotmeter_formula == 3) raw_needed = 1;   /* spotmeter, units: raw */
-        }
-
-        if (!raw_flag && raw_needed)
-        {
-            /* do we need any raw overlays? enable LV raw mode if we don't already have it */
-            raw_lv_request();
-            raw_flag = 1;
-        }
-        if (raw_flag && !raw_needed)
-        {
-            /* if we no longer need raw overlays, keep LiveView in normal mode (it does less stuff) */
-            raw_lv_release();
-            raw_flag = 0;
-        }
+		    int raw_needed = 0;
+
+		    /* if picture quality is raw, switch the LiveView to raw mode (photo, zoom 1x) */
+		    int raw = pic_quality & 0x60000;
+		    if ((raw && lv_dispsize == 1 && !is_movie_mode()) && ((zebra_draw && raw_zebra_enable == 1) || (hist_draw && RAW_HISTOGRAM_ENABLED) || (spotmeter_draw && spotmeter_formula == 3))) {
+		        /* only raw zebras, raw histogram and raw spotmeter are working in LV raw mode */            
+		        raw_needed = 1;        
+		        /* raw zebras: always */
+		        /* raw hisogram (any kind) */
+		        /* spotmeter, units: raw */                      
+		    }
+
+		    if (!raw_flag && raw_needed) {
+		        /* do we need any raw overlays? enable LV raw mode if we don't already have it */
+		        raw_lv_request();
+		        raw_flag = 1;
+		    }
+		    if (raw_flag && !raw_needed) {
+		        /* if we no longer need raw overlays, keep LiveView in normal mode (it does less stuff) */
+		        raw_lv_release();
+		        raw_flag = 0;
+		    }
         #endif
 
         int mz = should_draw_zoom_overlay();
@@ -4091,60 +4096,67 @@
         guess_fastrefresh_direction();
 
         #ifdef FEATURE_MAGIC_ZOOM
-        if (mz)
-        {
-            //~ msleep(k % 50 == 0 ? MIN_MSLEEP : 10);
-            if (zoom_overlay_dirty) BMP_LOCK( clrscr_mirror(); )
-            draw_zoom_overlay(zoom_overlay_dirty);
-            //~ BMP_LOCK( if (lv)  )
-            zoom_overlay_dirty = 0;
-            //~ crop_set_dirty(10); // don't draw cropmarks while magic zoom is active
-            // but redraw them after MZ is turned off
-            //~ continue;
-        }
-        else
+		    if (mz) {
+		        //~ msleep(k % 50 == 0 ? MIN_MSLEEP : 10);
+		        if (zoom_overlay_dirty) {
+		        	BMP_LOCK( clrscr_mirror(); );
+		        }
+		        draw_zoom_overlay(zoom_overlay_dirty);
+		        //~ BMP_LOCK( if (lv)  )
+		        zoom_overlay_dirty = 0;
+		        //~ crop_set_dirty(10); // don't draw cropmarks while magic zoom is active
+		        // but redraw them after MZ is turned off
+		        //~ continue;
+		    } else //?
         #endif
         {
-            if (!zoom_overlay_dirty) { redraw(); msleep(700); } // redraw cropmarks after MZ is turned off
+            if (!zoom_overlay_dirty) { 
+            	redraw(); 
+            	msleep(700); 
+            } // redraw cropmarks after MZ is turned off
             zoom_overlay_dirty = 1;
 
             msleep(10);
 
             #ifdef CONFIG_DISPLAY_FILTERS
-            /* to refactor with CBR */
-            extern void display_filter_step(int frame_number);
-            display_filter_step(k);
+		        /* to refactor with CBR */
+		        extern void display_filter_step(int frame_number);
+		        display_filter_step(k);
             #endif
             
             #ifdef FEATURE_FALSE_COLOR
-            if (falsecolor_draw)
-            {
-                if (k % 4 == 0)
-                    BMP_LOCK( if (lv) draw_false_downsampled(); )
-            }
-            else
+		        if (falsecolor_draw) {
+		            if (k % 4 == 0) {
+		                BMP_LOCK( if (lv) {
+		                	draw_false_downsampled(); 
+		                } );
+		            }
+		        } else //?
             #endif
             {
-                BMP_LOCK(
-                    if (lv)
-                        draw_zebra_and_focus(
-                            k % ((focus_peaking ? 5 : 3) * (RECORDING ? 5 : 1)) == 0, /* should redraw zebras? */
-                            k % 2 == 1  /* should redraw focus peaking? */
-                        ); 
-                )
+                BMP_LOCK( if (lv) {
+                	draw_zebra_and_focus( k % ((focus_peaking ? 5 : 3) * (RECORDING ? 5 : 1)) == 0, k % 2 == 1  /* should redraw zebras?, should redraw focus peaking? */
+                    ); 
+                } );
             }
         }
 
         #ifdef FEATURE_SPOTMETER
-        // update spotmeter every second, not more often than that
-        static int spotmeter_aux = 0;
-        if (spotmeter_draw && should_run_polling_action(1000, &spotmeter_aux))
-            BMP_LOCK( if (lv) spotmeter_step(); )
+		    // update spotmeter every second, not more often than that
+		    static int spotmeter_aux = 0;
+		    if (spotmeter_draw && should_run_polling_action(1000, &spotmeter_aux)) {
+		        BMP_LOCK( if (lv) {
+		        	spotmeter_step(); 
+		        } );
+		    }
         #endif
 
         #ifdef CONFIG_ELECTRONIC_LEVEL
-        if (electronic_level && k % 2)
-            BMP_LOCK( if (lv) show_electronic_level(); )
+		    if (electronic_level && k % 2) {
+		        BMP_LOCK( if (lv) {
+		        	show_electronic_level(); 
+		        } );
+		    }
         #endif
 
         #ifdef FEATURE_REC_NOTIFY
@@ -4154,89 +4166,101 @@
         #endif
         
         #ifdef FEATURE_MAGIC_ZOOM
-        if (zoom_overlay_triggered_by_focus_ring_countdown)
-        {
-            zoom_overlay_triggered_by_focus_ring_countdown--;
-        }
+		    if (zoom_overlay_triggered_by_focus_ring_countdown) {
+		        zoom_overlay_triggered_by_focus_ring_countdown--;
+		    }
         #endif
                 
         int m = 100;
-        if (lens_display_dirty) m = 10;
-        if (should_draw_zoom_overlay()) m = 100;
+        if (lens_display_dirty) {
+        	m = 10;
+        }
+        /*
+        if (should_draw_zoom_overlay()) {
+        	m = 100;
+        }
+        */
         
         int kmm = k % m;
-        if (!gui_menu_shown()) // don't update everything in one step, to reduce magic zoom flicker
-        {
-            #if defined(CONFIG_550D) || defined(CONFIG_5D2) || defined(CONFIG_50D) || defined(CONFIG_7D)
-            if (kmm == 0)
-                BMP_LOCK( if (lv) black_bars(); )
-            #endif
-
-            if (kmm == 2)
-            {
-                BMP_LOCK( if (lv) update_lens_display(1,0); );
-                if (lens_display_dirty) lens_display_dirty--;
-            }
-
-            if (kmm == 8)
-            {
-                BMP_LOCK( if (lv) update_lens_display(0,1); );
-                if (lens_display_dirty) lens_display_dirty--;
-            }
+        if (!gui_menu_shown()) { // don't update everything in one step, to reduce magic zoom flicker
+        	
+        	switch (kmm) {
+        		#if defined(CONFIG_550D) || defined(CONFIG_5D2) || defined(CONFIG_50D) || defined(CONFIG_7D)
+		    		case 0:
+		    			BMP_LOCK( if (lv) {
+		            		black_bars(); 
+		            	} );
+		    			break;
+        		#endif
+        		
+        		case 2:
+        			BMP_LOCK( if (lv) {
+                		update_lens_display(1,0); 
+                	} );
+		            if (lens_display_dirty) {
+		            	lens_display_dirty--;
+		            }
+        			break;
+        		
+        		case 8:
+        			BMP_LOCK( if (lv) {
+                		update_lens_display(0,1);
+                	} );
+		            if (lens_display_dirty) {
+		            	lens_display_dirty--;
+		            }
+        			break;
+        	}
         }
     }
 }
 
-static void loprio_sleep()
-{
+static void loprio_sleep() {
     msleep(200);
-    while (is_mvr_buffer_almost_full()) msleep(100);
+    while (is_mvr_buffer_almost_full()) {
+    	msleep(100);
+    }
 }
 
 // Items which do not need a high FPS, but are CPU intensive
 // histogram, waveform...
-static void
-livev_lopriority_task( void* unused )
-{
+static void livev_lopriority_task( void* unused ) {
     msleep(500);
-    TASK_LOOP
-    {
+    TASK_LOOP {
         #ifdef FEATURE_CROPMARKS
-        #ifdef FEATURE_GHOST_IMAGE
-        if (transparent_overlay_flag)
-        {
-            transparent_overlay_from_play();
-            transparent_overlay_flag = 0;
-        }
-        #endif
-
-        // here, redrawing cropmarks does not block fast zoom
-        if (crop_enabled && cropmarks_play && PLAY_MODE && DISPLAY_IS_ON && (int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) <= 0)
-        {
-            msleep(500);
-            if (PLAY_MODE && DISPLAY_IS_ON && ((int32_t)(int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) <= 0)) // double-check
-            {
-                cropmark_redraw();
-                if ((int32_t)(int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) >= 0) redraw(); // whoops, CTRL-Z, CTRL-Z :)
-            }
-        }
+        	#ifdef FEATURE_GHOST_IMAGE
+				if (transparent_overlay_flag) {
+				    transparent_overlay_from_play();
+				    transparent_overlay_flag = 0;
+				}
+        	#endif
+
+		    // here, redrawing cropmarks does not block fast zoom
+		    if (crop_enabled && cropmarks_play && PLAY_MODE && DISPLAY_IS_ON && (int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) <= 0) {
+		        msleep(500);
+		        if (PLAY_MODE && DISPLAY_IS_ON && ((int32_t)(int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) <= 0)) { // double-check		        
+		            cropmark_redraw();
+		            if ((int32_t)(int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) >= 0) {
+		            	redraw(); // whoops, CTRL-Z, CTRL-Z :)
+		            }
+		        }
+		    }
         #endif
 
         loprio_sleep();
-        if (!zebra_should_run())
-        {
-            if (WAVEFORM_FULLSCREEN && liveview_display_idle() && get_global_draw() && !is_zoom_mode_so_no_zebras() && !gui_menu_shown())
-            {
-                if (get_halfshutter_pressed()) clrscr();
-                else draw_histogram_and_waveform(0);
+        if (!zebra_should_run()) {
+            if (WAVEFORM_FULLSCREEN && liveview_display_idle() && get_global_draw() && !is_zoom_mode_so_no_zebras() && !gui_menu_shown()) {
+                if (get_halfshutter_pressed()) {
+                	clrscr();
+                } else {
+                	draw_histogram_and_waveform(0);
+                }
             }
-            continue;
         }
 
         loprio_sleep();
 
-        if (!gui_menu_shown())
-        {
+        if (!gui_menu_shown()) {
             draw_histogram_and_waveform(0);
         }
     }
@@ -4248,229 +4272,233 @@
 TASK_CREATE( "livev_loprio_task", livev_lopriority_task, 0, 0x1f, 0x8000 );
 
 // these may be out of order for config compatibility
-void update_disp_mode_bits_from_params()
-{
-//~ BMP_LOCK(
-    uint32_t bits =
-        (global_draw & 1      ? 1<<0 : 0) |
-        (zebra_draw           ? 1<<1 : 0) |
-#ifdef FEATURE_HISTOGRAM
-        (hist_draw            ? 1<<2 : 0) |
-#endif
-        (crop_enabled         ? 1<<3 : 0) |
-        (waveform_draw        ? 1<<4 : 0) |
-        (falsecolor_draw      ? 1<<5 : 0) |
-        (spotmeter_draw       ? 1<<6 : 0) |
-        (global_draw & 2      ? 1<<7 : 0) |
-        (focus_peaking        ? 1<<8 : 0) |
-        (zoom_overlay_enabled ? 1<<9 : 0) |
-        (transparent_overlay  ? 1<<10: 0) |
-        (electronic_level     ? 1<<11: 0) |
-        //~ (defish_preview       ? 1<<12: 0) |
-#ifdef FEATURE_VECTORSCOPE
-        (vectorscope_should_draw() ? 1<<13: 0) |
-#else
-        0 |
-#endif
-        0;
-        
-    if (disp_mode == 1) disp_mode_a = bits;
-    else if (disp_mode == 2) disp_mode_b = bits;
-    else if (disp_mode == 3) disp_mode_c = bits;
-    else disp_mode_x = bits;
-//~ )
+void update_disp_mode_bits_from_params() {
+	//~ BMP_LOCK(
+		uint32_t bits = (global_draw & 1      ? 1<<0 : 0) |
+		    			(zebra_draw           ? 1<<1 : 0) |
+						#ifdef FEATURE_HISTOGRAM
+		    				(hist_draw            ? 1<<2 : 0) |
+						#endif
+						(crop_enabled         ? 1<<3 : 0) |
+						(waveform_draw        ? 1<<4 : 0) |
+						(falsecolor_draw      ? 1<<5 : 0) |
+						(spotmeter_draw       ? 1<<6 : 0) |
+						(global_draw & 2      ? 1<<7 : 0) |
+						(focus_peaking        ? 1<<8 : 0) |
+						(zoom_overlay_enabled ? 1<<9 : 0) |
+						(transparent_overlay  ? 1<<10: 0) |
+						(electronic_level     ? 1<<11: 0) |
+						//~ (defish_preview       ? 1<<12: 0) |
+						#ifdef FEATURE_VECTORSCOPE
+		    				(vectorscope_should_draw() ? 1<<13: 0) |
+						#else
+		    				0 |
+						#endif
+		    			0;
+		
+		switch (disp_mode) {
+			case 1:
+				disp_mode_a = bits;
+				break;
+			case 2:
+				disp_mode_b = bits;
+				break;
+			case 3:
+				disp_mode_c = bits;
+				break;
+				
+			default:
+				disp_mode_x = bits;
+				break;				
+		}  		
+	//~ )
 }
 
-void update_disp_mode_params_from_bits()
-{
-//~ BMP_LOCK(
-    uint32_t bits = disp_mode == 1 ? disp_mode_a : 
-                    disp_mode == 2 ? disp_mode_b :
-                    disp_mode == 3 ? disp_mode_c : disp_mode_x;
-
-    int global_draw_0    = bits & (1<<0) ? 1 : 0;
-    zebra_draw           = bits & (1<<1) ? 1 : 0;
-#ifdef FEATURE_HISTOGRAM
-    hist_draw            = bits & (1<<2) ? 1 : 0;
-#endif
-    crop_enabled         = bits & (1<<3) ? 1 : 0;
-    waveform_draw        = bits & (1<<4) ? 1 : 0;
-    falsecolor_draw      = bits & (1<<5) ? 1 : 0;
-    spotmeter_draw       = bits & (1<<6) ? 1 : 0;
-    int global_draw_1    = bits & (1<<7) ? 1 : 0;
-    focus_peaking        = bits & (1<<8) ? 1 : 0;
-    zoom_overlay_enabled = bits & (1<<9) ? 1 : 0;
-    transparent_overlay  = bits & (1<<10)? 1 : 0;
-    electronic_level     = bits & (1<<11)? 1 : 0;
-    //~ defish_preview       = bits & (1<<12)? 1 : 0;
-#ifdef FEATURE_VECTORSCOPE
-    vectorscope_request_draw(bits & (1<<13)? 1 : 0);
-#endif
-    global_draw = global_draw_0 + global_draw_1 * 2;
-//~ end:
-//~ )
+void update_disp_mode_params_from_bits() {
+	//~ BMP_LOCK(
+		uint32_t bits = disp_mode == 1 ? disp_mode_a : 
+		                disp_mode == 2 ? disp_mode_b :
+		                disp_mode == 3 ? disp_mode_c : disp_mode_x;
+
+		int global_draw_0    = bits & (1<<0) ? 1 : 0;
+		zebra_draw           = bits & (1<<1) ? 1 : 0;
+		#ifdef FEATURE_HISTOGRAM
+			hist_draw            = bits & (1<<2) ? 1 : 0;
+		#endif
+		crop_enabled         = bits & (1<<3) ? 1 : 0;
+		waveform_draw        = bits & (1<<4) ? 1 : 0;
+		falsecolor_draw      = bits & (1<<5) ? 1 : 0;
+		spotmeter_draw       = bits & (1<<6) ? 1 : 0;
+		int global_draw_1    = bits & (1<<7) ? 1 : 0;
+		focus_peaking        = bits & (1<<8) ? 1 : 0;
+		zoom_overlay_enabled = bits & (1<<9) ? 1 : 0;
+		transparent_overlay  = bits & (1<<10)? 1 : 0;
+		electronic_level     = bits & (1<<11)? 1 : 0;
+		//~ defish_preview       = bits & (1<<12)? 1 : 0;
+		#ifdef FEATURE_VECTORSCOPE
+			vectorscope_request_draw(bits & (1<<13)? 1 : 0);
+		#endif
+		global_draw = global_draw_0 + global_draw_1 * 2;
+	//~ end:
+	//~ )
 }
 
-int get_disp_mode() { return disp_mode; }
+int get_disp_mode() { 
+	return disp_mode; 
+}
 
 static void toggle_disp_mode_menu(void *priv, int delta) {
-    if (!disp_profiles_0) menu_toggle_submenu();
-    else toggle_disp_mode();
+    if (!disp_profiles_0) {
+    	menu_toggle_submenu();
+    } else {
+    	toggle_disp_mode();
+    }
 }
 
-int toggle_disp_mode()
-{
+int toggle_disp_mode() {
     update_disp_mode_bits_from_params();
     idle_wakeup_reset_counters(-3);
     disp_mode = MOD(disp_mode + 1, disp_profiles_0 + 1);
     BMP_LOCK( do_disp_mode_change(); )
     //~ menu_set_dirty();
-    return disp_mode == 0;
+    return (disp_mode == 0);
+}
+
+static void do_disp_mode_change() {
+    if (gui_menu_shown()) { 
+        update_disp_mode_params_from_bits();         
+    } else {    
+		display_on();
+		bmp_on();
+		clrscr();
+		idle_globaldraw_dis();
+		//~ redraw();
+		bmp_printf(SHADOW_FONT(FONT_LARGE), 50, 50, "Display preset: %d", disp_mode);
+		msleep(250);
+		idle_globaldraw_en();
+		update_disp_mode_params_from_bits();
+		redraw();
+    }
 }
-static void do_disp_mode_change()
-{
-    if (gui_menu_shown()) 
-    { 
-        update_disp_mode_params_from_bits(); 
-        return; 
+
+int handle_disp_preset_key(struct event * event) {
+    /*the INFO key may be also used for enabling powersaving right away
+      if display presets are off: pressing INFO will go to powersave (if any of those modes are enabled)
+      if display presets are on: powersave will act somewhat like an extra display preset
+    */
+    int value = 0;
+     
+    if (event->param == BGMT_INFO) {
+        if (!disp_profiles_0) {
+        	value = handle_powersave_key(event);
+		} else {
+
+		    if ((!lv && !LV_PAUSED) || IS_FAKE(event) || gui_menu_shown()) {        	
+		    	value = 1;
+			} else {
+				
+				if (idle_is_powersave_enabled_on_info_disp_key()) {
+				    if (disp_mode == disp_profiles_0 && !idle_is_powersave_active()) {
+				    	value = handle_powersave_key(event);				       
+				    } else {
+				        toggle_disp_mode(); // and wake up from powersave
+				    }
+				} else {
+				    toggle_disp_mode();
+				}								
+			}
+		}
     }
     
-    display_on();
-    bmp_on();
-    clrscr();
-    idle_globaldraw_dis();
-    //~ redraw();
-    bmp_printf(SHADOW_FONT(FONT_LARGE), 50, 50, "Display preset: %d", disp_mode);
-    msleep(250);
-    idle_globaldraw_en();
-    update_disp_mode_params_from_bits();
-    redraw();
-}
-
-int handle_disp_preset_key(struct event * event)
-{
-    // the INFO key may be also used for enabling powersaving right away
-    // if display presets are off: pressing INFO will go to powersave (if any of those modes are enabled)
-    // if display presets are on: powersave will act somewhat like an extra display preset
-    
-    if (event->param == BGMT_INFO)
-    {
-        if (!disp_profiles_0)
-            return handle_powersave_key(event);
-
-        if (!lv && !LV_PAUSED) return 1;
-        if (IS_FAKE(event)) return 1;
-        if (gui_menu_shown()) return 1;
-        
-        if (idle_is_powersave_enabled_on_info_disp_key())
-        {
-            if (disp_mode == disp_profiles_0 && !idle_is_powersave_active())
-                return handle_powersave_key(event);
-            else
-                toggle_disp_mode(); // and wake up from powersave
-        }
-        else
-        {
-            toggle_disp_mode();
-        }
-        return 0;
-    }
-    return 1;
+    value = 1;
+    return value;
 }
 
 #ifdef FEATURE_OVERLAYS_IN_PLAYBACK_MODE
-static int overlays_playback_displayed = 0;
-
-static void overlays_playback_clear()
-{
-    if (overlays_playback_displayed)
-    {
-        clrscr();
-        digic_zebra_cleanup();
-        redraw();
-        overlays_playback_displayed = 0;
-    }
-}
-
-/* called from GUI handler */
-static void overlays_playback_toggle()
-{
-    if (overlays_playback_running)
-        return;
-    
-    if (!overlays_playback_displayed)
-    {
-        /* this may take about 1 second, so let's run it outside GuiMainTask */
-        overlays_playback_running = 1;
-        task_create("lv_playback", 0x1a, 0x8000, draw_overlays_playback, 0);
-        overlays_playback_displayed = 1;
-    }
-    else
-    {
-        overlays_playback_clear();
-    }
-}
-
-int handle_overlays_playback(struct event * event)
-{
-    // enable LiveV stuff in Play mode
-    if (PLAY_OR_QR_MODE)
-    {
-        switch(event->param)
-        {
-#if defined(BTN_ZEBRAS_FOR_PLAYBACK) && defined(BTN_ZEBRAS_FOR_PLAYBACK_NAME)
-            case BTN_ZEBRAS_FOR_PLAYBACK:
-                /* used in PLAY mode (user pressed button to toggle overlays) */
-                overlays_playback_toggle();
-                return 0;
+	static int overlays_playback_displayed = 0;
+
+	static void overlays_playback_clear() {
+		if (overlays_playback_displayed) {
+		    clrscr();
+		    digic_zebra_cleanup();
+		    redraw();
+		    overlays_playback_displayed = 0;
+		}
+	}
+
+	/* called from GUI handler */
+	static void overlays_playback_toggle() {
+		if (!overlays_playback_running) {                
+			if (!overlays_playback_displayed) {
+				/* this may take about 1 second, so let's run it outside GuiMainTask */
+				overlays_playback_running = 1;
+				task_create("lv_playback", 0x1a, 0x8000, draw_overlays_playback, 0);
+				overlays_playback_displayed = 1;
+			} else {
+				overlays_playback_clear();
+			}
+		}
+	}
+
+	int handle_overlays_playback(struct event * event) {
+		int value=0; 
+		// enable LiveV stuff in Play mode
+		if (PLAY_OR_QR_MODE) {
+		    switch(event->param) {
+				#if defined(BTN_ZEBRAS_FOR_PLAYBACK) && defined(BTN_ZEBRAS_FOR_PLAYBACK_NAME)
+				    case BTN_ZEBRAS_FOR_PLAYBACK:
+				        /* used in PLAY mode (user pressed button to toggle overlays) */
+				        overlays_playback_toggle();                
+				        break;
+				#endif
+		        case MLEV_TRIGGER_ZEBRAS_FOR_PLAYBACK:
+		            /* used in QuickReview mode - always show the overlays, no toggle */
+		            overlays_playback_displayed = 0;
+		            overlays_playback_toggle();                
+		            break;
+		    }
+		    
+		    if (event->param == GMT_OLC_INFO_CHANGED) {
+		    	value=1;
+			} else {
+			
+				#ifdef GMT_GUICMD_PRESS_BUTTON_SOMETHING
+					if (event->param == GMT_GUICMD_PRESS_BUTTON_SOMETHING) {
+						value=1;
+					} else {
+				#endif
+				
+						/* some button pressed in play mode, while ML overlays are active? clear them */
+						overlays_playback_clear();
+				#ifdef GMT_GUICMD_PRESS_BUTTON_SOMETHING
+					}
+				#endif
+			
+			}		
+		} else {
+		    /* got out of play mode? ML overlays are for sure no longer active */
+		    overlays_playback_displayed = 0;
+		}
+		value=1;
+		return value; 
+	}
 #endif
-            case MLEV_TRIGGER_ZEBRAS_FOR_PLAYBACK:
-                /* used in QuickReview mode - always show the overlays, no toggle */
-                overlays_playback_displayed = 0;
-                overlays_playback_toggle();
-                return 0;
-        }
-        
-        if (event->param == GMT_OLC_INFO_CHANGED)
-            return 1;
-
-        #ifdef GMT_GUICMD_PRESS_BUTTON_SOMETHING
-        else if (event->param == GMT_GUICMD_PRESS_BUTTON_SOMETHING)
-            return 1;
-        #endif
-
-        else
-        {
-            /* some button pressed in play mode, while ML overlays are active? clear them */
-            overlays_playback_clear();
-        }
-    }
-    else
-    {
-        /* got out of play mode? ML overlays are for sure no longer active */
-        overlays_playback_displayed = 0;
-    }
-    return 1;
-}
-#endif
-
-static void zebra_init()
-{
+
+static void zebra_init() {
     precompute_yuv2rgb();
     menu_add( "Overlay", zebra_menus, COUNT(zebra_menus) );
     menu_add( "Debug", livev_dbg_menus, COUNT(livev_dbg_menus) );
     //~ menu_add( "Movie", movie_menus, COUNT(movie_menus) );
     //~ menu_add( "Config", cfg_menus, COUNT(cfg_menus) );
     #ifdef FEATURE_CROPMARKS
-    menu_add( "Overlay", cropmarks_menu, COUNT(cropmarks_menu) );
+    	menu_add( "Overlay", cropmarks_menu, COUNT(cropmarks_menu) );
     #endif
 }
 
 INIT_FUNC(__FILE__, zebra_init);
 
 
-static void make_overlay()
-{
+static void make_overlay() {
     //~ draw_cropmark_area();
     msleep(1000);
     //~ bvram_mirror_init();
@@ -4480,99 +4508,91 @@
 
     struct vram_info * vram = get_yuv422_vram();
     uint8_t * const lvram = vram->vram;
-    if (!lvram) return;
-
-    uint8_t * const bvram = bmp_vram();
-    if (!bvram) return;
-
-    // difficulty: in play mode, image buffer may have different size/position than in LiveView
-    // => normalized xn and yn will fix this
-    for (int yn = 0; yn < 480; yn++)
-    {
-        int y = N2BM_Y(yn);
-        //~ int k;
-        uint16_t * const v_row = (uint16_t*)( lvram        + BM2LV_R(y)); // 1 pixel
-        uint8_t  * const b_row = (uint8_t*) ( bvram        + BM_R(y));    // 1 pixel
-        uint8_t  * const m_row = (uint8_t*) ( bvram_mirror + BM_R(yn));    // 1 pixel
-        uint16_t* lvp; // that's a moving pointer through lv vram
-        uint8_t* bp;   // through bmp vram
-        uint8_t* mp;   // through bmp vram mirror
-        for (int xn = 0; xn < 720; xn++)
-        {
-            int x = N2BM_X(xn);
-            lvp = v_row + BM2LV_X(x);
-            bp = b_row + x;
-            mp = m_row + xn;
-            *bp = *mp = ((*lvp) * 41 >> 16) + 38;
-        }
-    }
-    FILE* f = FIO_CreateFile("ML/DATA/overlay.dat");
-    if (f)
-    {
-        FIO_WriteFile( f, (const void *) bvram_mirror, BVRAM_MIRROR_SIZE);
-        FIO_CloseFile(f);
-        bmp_printf(FONT_MED, 0, 0, "Overlay saved.  ");
-    }
-    else
-    {
-        bmp_printf(FONT_MED, 0, 0, "Overlay error.  ");
-    }
-    msleep(1000);
+    if (lvram) {			
+		uint8_t * const bvram = bmp_vram();
+		if (bvram) {			
+			// difficulty: in play mode, image buffer may have different size/position than in LiveView
+			// => normalized xn and yn will fix this
+			for (int yn = 0; yn < 480; yn++) {
+				int y = N2BM_Y(yn);
+				//~ int k;
+				uint16_t * const v_row = (uint16_t*)( lvram        + BM2LV_R(y)); // 1 pixel
+				uint8_t  * const b_row = (uint8_t*) ( bvram        + BM_R(y));    // 1 pixel
+				uint8_t  * const m_row = (uint8_t*) ( bvram_mirror + BM_R(yn));    // 1 pixel
+				uint16_t* lvp; // that's a moving pointer through lv vram
+				uint8_t* bp;   // through bmp vram
+				uint8_t* mp;   // through bmp vram mirror
+				for (int xn = 0; xn < 720; xn++) {
+				    int x = N2BM_X(xn);
+				    lvp = v_row + BM2LV_X(x);
+				    bp = b_row + x;
+				    mp = m_row + xn;
+				    *bp = *mp = ((*lvp) * 41 >> 16) + 38;
+				}
+			}
+			FILE* f = FIO_CreateFile("ML/DATA/overlay.dat");
+			if (f) {
+				FIO_WriteFile( f, (const void *) bvram_mirror, BVRAM_MIRROR_SIZE);
+				FIO_CloseFile(f);
+				bmp_printf(FONT_MED, 0, 0, "Overlay saved.  ");
+			} else {
+				bmp_printf(FONT_MED, 0, 0, "Overlay error.  ");
+			}
+			msleep(1000);
+		}
+	}
 }
 
-static void show_overlay()
-{
+static void show_overlay() {
     //~ bvram_mirror_init();
     //~ struct vram_info * vram = get_yuv422_vram();
     //~ uint8_t * const lvram = vram->vram;
     //~ int lvpitch = YUV422_LV_PITCH;
     get_yuv422_vram();
     uint8_t * const bvram = bmp_vram_real();
-    if (!bvram) return;
-    
-    clrscr();
-
-    int size = 0;
-    void * tmp = read_entire_file("ML/DATA/overlay.dat", &size);
-    if (tmp)
-    {
-        ASSERT(size == BVRAM_MIRROR_SIZE);
-        memcpy(bvram_mirror, tmp, BVRAM_MIRROR_SIZE);
-        free(tmp); tmp = NULL;
-    }
-
-    for (int y = os.y0; y < os.y_max; y++)
-    {
-        int yn = BM2N_Y(y);
-        int ym = yn - (int)transparent_overlay_offy; // normalized with offset applied
-        //~ int k;
-        //~ uint16_t * const v_row = (uint16_t*)( lvram + y * lvpitch );        // 1 pixel
-        uint8_t * const b_row = (uint8_t*)( bvram + y * BMPPITCH);          // 1 pixel
-        uint8_t * const m_row = (uint8_t*)( bvram_mirror + ym * BMPPITCH);   // 1 pixel
-        uint8_t* bp;  // through bmp vram
-        uint8_t* mp;  //through bmp vram mirror
-        if (ym < 0 || ym > 480) continue;
-        //~ int offm = 0;
-        //~ int offb = 0;
-        //~ if (transparent_overlay == 2) offm = 720/2;
-        //~ if (transparent_overlay == 3) offb = 720/2;
-        for (int x = os.x0; x < os.x_max; x++)
-        {
-            int xn = BM2N_X(x);
-            int xm = xn - (int)transparent_overlay_offx;
-            bp = b_row + x;
-            mp = m_row + xm;
-            if (((x+y) % 2) && xm >= 0 && xm <= 720)
-                *bp = *mp;
-        }
-    }
-    
-    bvram_mirror_clear();
-    afframe_clr_dirty();
+    if (bvram) {					
+		clrscr();
+
+		int size = 0;
+		void * tmp = read_entire_file("ML/DATA/overlay.dat", &size);
+		if (tmp) {
+		    ASSERT(size == BVRAM_MIRROR_SIZE);
+		    memcpy(bvram_mirror, tmp, BVRAM_MIRROR_SIZE);
+		    free(tmp); tmp = NULL;
+		}
+
+		for (int y = os.y0; y < os.y_max; y++) {
+		    int yn = BM2N_Y(y);
+		    int ym = yn - (int)transparent_overlay_offy; // normalized with offset applied
+		    //~ int k;
+		    //~ uint16_t * const v_row = (uint16_t*)( lvram + y * lvpitch );        // 1 pixel
+		    uint8_t * const b_row = (uint8_t*)( bvram + y * BMPPITCH);          // 1 pixel
+		    uint8_t * const m_row = (uint8_t*)( bvram_mirror + ym * BMPPITCH);   // 1 pixel
+		    uint8_t* bp;  // through bmp vram
+		    uint8_t* mp;  //through bmp vram mirror
+		    if (ym < 0 || ym > 480) {		    	
+				//~ int offm = 0;
+				//~ int offb = 0;
+				//~ if (transparent_overlay == 2) offm = 720/2;
+				//~ if (transparent_overlay == 3) offb = 720/2;
+				for (int x = os.x0; x < os.x_max; x++) {
+				    int xn = BM2N_X(x);
+				    int xm = xn - (int)transparent_overlay_offx;
+				    bp = b_row + x;
+				    mp = m_row + xm;
+				    if (((x+y) % 2) && xm >= 0 && xm <= 720) {
+				        *bp = *mp;
+				    }
+				}
+			}
+		}
+		
+		bvram_mirror_clear();
+		afframe_clr_dirty();
+	}
 }
 
-static void transparent_overlay_from_play()
-{
+static void transparent_overlay_from_play() {
     /* go to play mode if not already there */
     enter_play_mode();
     
@@ -4585,12 +4605,13 @@
     /* the overlay will now be displayed from cropmarks.c */
 }
 
-PROP_HANDLER(PROP_LV_ACTION)
-{
+PROP_HANDLER(PROP_LV_ACTION) {
     zoom_overlay_triggered_by_focus_ring_countdown = 0;
     
     idle_globaldraw_disable = 0;
-    if (buf[0] == 0) lv_paused = 0;
+    if (buf[0] == 0) {
+    	lv_paused = 0;
+    }
     
     #ifdef FEATURE_EXPO_OVERRIDE
     bv_auto_update();
@@ -4601,8 +4622,7 @@
     #endif
 }
 
-void peaking_benchmark()
-{
+void peaking_benchmark() {
     int old_lv = lv;
     int old_peaking = focus_peaking;
     focus_peaking = 1;
@@ -4611,8 +4631,7 @@
     msleep(2000);
     int a = get_seconds_clock();
     lv = 1; // lie, to force using the liveview algorithm which is relevant for benchmarking
-    for (int i = 0; i < 1000; i++)
-    {
+    for (int i = 0; i < 1000; i++) {
         draw_zebra_and_focus(0,1);
     }
     int b = get_seconds_clock();




