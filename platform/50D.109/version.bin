

Magic Lantern Nightly.2021Mar25.50D109
Camera   : 50D
Firmware : 109
Changeset: 352a05ff20db+ (qemu)
Built on : 2021-03-25 20:48:13 by david@david-VirtualBox

diff -r 352a05ff20db src/module.h
--- a/src/module.h	Wed Mar 24 17:35:08 2021 +0000
+++ b/src/module.h	Thu Mar 25 21:48:13 2021 +0100
@@ -340,8 +340,10 @@
 /* see propvalues.c */
 extern int is_camera(const char * model, const char * firmware);
 
+/* esto fue comentado
 #ifdef MODULE
-#include "module_strings.h"
+	#include "module_strings.h" 
 #endif
+*/
 
 #endif
diff -r 352a05ff20db src/zebra.c
--- a/src/zebra.c	Wed Mar 24 17:35:08 2021 +0000
+++ b/src/zebra.c	Thu Mar 25 21:48:13 2021 +0100
@@ -4187,39 +4187,36 @@
     }
 }
 
-static void loprio_sleep()
-{
+static void loprio_sleep() {
     msleep(200);
-    while (is_mvr_buffer_almost_full()) msleep(100);
+    while (is_mvr_buffer_almost_full()) {
+    	msleep(100);
+    }
 }
 
 // Items which do not need a high FPS, but are CPU intensive
 // histogram, waveform...
-static void
-livev_lopriority_task( void* unused )
-{
+static void livev_lopriority_task( void* unused ) {
     msleep(500);
-    TASK_LOOP
-    {
+    TASK_LOOP {
         #ifdef FEATURE_CROPMARKS
-        #ifdef FEATURE_GHOST_IMAGE
-        if (transparent_overlay_flag)
-        {
-            transparent_overlay_from_play();
-            transparent_overlay_flag = 0;
-        }
-        #endif
-
-        // here, redrawing cropmarks does not block fast zoom
-        if (crop_enabled && cropmarks_play && PLAY_MODE && DISPLAY_IS_ON && (int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) <= 0)
-        {
-            msleep(500);
-            if (PLAY_MODE && DISPLAY_IS_ON && ((int32_t)(int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) <= 0)) // double-check
-            {
-                cropmark_redraw();
-                if ((int32_t)(int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) >= 0) redraw(); // whoops, CTRL-Z, CTRL-Z :)
-            }
-        }
+        	#ifdef FEATURE_GHOST_IMAGE
+				if (transparent_overlay_flag) {
+				    transparent_overlay_from_play();
+				    transparent_overlay_flag = 0;
+				}
+        	#endif
+
+		    // here, redrawing cropmarks does not block fast zoom
+		    if (crop_enabled && cropmarks_play && PLAY_MODE && DISPLAY_IS_ON && (int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) <= 0) {
+		        msleep(500);
+		        if (PLAY_MODE && DISPLAY_IS_ON && ((int32_t)(int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) <= 0)) { // double-check		        
+		            cropmark_redraw();
+		            if ((int32_t)(int32_t)MEM(IMGPLAY_ZOOM_LEVEL_ADDR) >= 0) {
+		            	redraw(); // whoops, CTRL-Z, CTRL-Z :)
+		            }
+		        }
+		    }
         #endif
 
         loprio_sleep();
@@ -4235,8 +4232,7 @@
 
         loprio_sleep();
 
-        if (!gui_menu_shown())
-        {
+        if (!gui_menu_shown()) {
             draw_histogram_and_waveform(0);
         }
     }
@@ -4248,229 +4244,233 @@
 TASK_CREATE( "livev_loprio_task", livev_lopriority_task, 0, 0x1f, 0x8000 );
 
 // these may be out of order for config compatibility
-void update_disp_mode_bits_from_params()
-{
-//~ BMP_LOCK(
-    uint32_t bits =
-        (global_draw & 1      ? 1<<0 : 0) |
-        (zebra_draw           ? 1<<1 : 0) |
-#ifdef FEATURE_HISTOGRAM
-        (hist_draw            ? 1<<2 : 0) |
-#endif
-        (crop_enabled         ? 1<<3 : 0) |
-        (waveform_draw        ? 1<<4 : 0) |
-        (falsecolor_draw      ? 1<<5 : 0) |
-        (spotmeter_draw       ? 1<<6 : 0) |
-        (global_draw & 2      ? 1<<7 : 0) |
-        (focus_peaking        ? 1<<8 : 0) |
-        (zoom_overlay_enabled ? 1<<9 : 0) |
-        (transparent_overlay  ? 1<<10: 0) |
-        (electronic_level     ? 1<<11: 0) |
-        //~ (defish_preview       ? 1<<12: 0) |
-#ifdef FEATURE_VECTORSCOPE
-        (vectorscope_should_draw() ? 1<<13: 0) |
-#else
-        0 |
-#endif
-        0;
-        
-    if (disp_mode == 1) disp_mode_a = bits;
-    else if (disp_mode == 2) disp_mode_b = bits;
-    else if (disp_mode == 3) disp_mode_c = bits;
-    else disp_mode_x = bits;
-//~ )
+void update_disp_mode_bits_from_params() {
+	//~ BMP_LOCK(
+		uint32_t bits = (global_draw & 1      ? 1<<0 : 0) |
+		    			(zebra_draw           ? 1<<1 : 0) |
+						#ifdef FEATURE_HISTOGRAM
+		    				(hist_draw            ? 1<<2 : 0) |
+						#endif
+						(crop_enabled         ? 1<<3 : 0) |
+						(waveform_draw        ? 1<<4 : 0) |
+						(falsecolor_draw      ? 1<<5 : 0) |
+						(spotmeter_draw       ? 1<<6 : 0) |
+						(global_draw & 2      ? 1<<7 : 0) |
+						(focus_peaking        ? 1<<8 : 0) |
+						(zoom_overlay_enabled ? 1<<9 : 0) |
+						(transparent_overlay  ? 1<<10: 0) |
+						(electronic_level     ? 1<<11: 0) |
+						//~ (defish_preview       ? 1<<12: 0) |
+						#ifdef FEATURE_VECTORSCOPE
+		    				(vectorscope_should_draw() ? 1<<13: 0) |
+						#else
+		    				0 |
+						#endif
+		    			0;
+		
+		switch (disp_mode) {
+			case 1:
+				disp_mode_a = bits;
+				break;
+			case 2:
+				disp_mode_b = bits;
+				break;
+			case 3:
+				disp_mode_c = bits;
+				break;
+				
+			default:
+				disp_mode_x = bits;
+				break;				
+		}  		
+	//~ )
 }
 
-void update_disp_mode_params_from_bits()
-{
-//~ BMP_LOCK(
-    uint32_t bits = disp_mode == 1 ? disp_mode_a : 
-                    disp_mode == 2 ? disp_mode_b :
-                    disp_mode == 3 ? disp_mode_c : disp_mode_x;
-
-    int global_draw_0    = bits & (1<<0) ? 1 : 0;
-    zebra_draw           = bits & (1<<1) ? 1 : 0;
-#ifdef FEATURE_HISTOGRAM
-    hist_draw            = bits & (1<<2) ? 1 : 0;
-#endif
-    crop_enabled         = bits & (1<<3) ? 1 : 0;
-    waveform_draw        = bits & (1<<4) ? 1 : 0;
-    falsecolor_draw      = bits & (1<<5) ? 1 : 0;
-    spotmeter_draw       = bits & (1<<6) ? 1 : 0;
-    int global_draw_1    = bits & (1<<7) ? 1 : 0;
-    focus_peaking        = bits & (1<<8) ? 1 : 0;
-    zoom_overlay_enabled = bits & (1<<9) ? 1 : 0;
-    transparent_overlay  = bits & (1<<10)? 1 : 0;
-    electronic_level     = bits & (1<<11)? 1 : 0;
-    //~ defish_preview       = bits & (1<<12)? 1 : 0;
-#ifdef FEATURE_VECTORSCOPE
-    vectorscope_request_draw(bits & (1<<13)? 1 : 0);
-#endif
-    global_draw = global_draw_0 + global_draw_1 * 2;
-//~ end:
-//~ )
+void update_disp_mode_params_from_bits() {
+	//~ BMP_LOCK(
+		uint32_t bits = disp_mode == 1 ? disp_mode_a : 
+		                disp_mode == 2 ? disp_mode_b :
+		                disp_mode == 3 ? disp_mode_c : disp_mode_x;
+
+		int global_draw_0    = bits & (1<<0) ? 1 : 0;
+		zebra_draw           = bits & (1<<1) ? 1 : 0;
+		#ifdef FEATURE_HISTOGRAM
+			hist_draw            = bits & (1<<2) ? 1 : 0;
+		#endif
+		crop_enabled         = bits & (1<<3) ? 1 : 0;
+		waveform_draw        = bits & (1<<4) ? 1 : 0;
+		falsecolor_draw      = bits & (1<<5) ? 1 : 0;
+		spotmeter_draw       = bits & (1<<6) ? 1 : 0;
+		int global_draw_1    = bits & (1<<7) ? 1 : 0;
+		focus_peaking        = bits & (1<<8) ? 1 : 0;
+		zoom_overlay_enabled = bits & (1<<9) ? 1 : 0;
+		transparent_overlay  = bits & (1<<10)? 1 : 0;
+		electronic_level     = bits & (1<<11)? 1 : 0;
+		//~ defish_preview       = bits & (1<<12)? 1 : 0;
+		#ifdef FEATURE_VECTORSCOPE
+			vectorscope_request_draw(bits & (1<<13)? 1 : 0);
+		#endif
+		global_draw = global_draw_0 + global_draw_1 * 2;
+	//~ end:
+	//~ )
 }
 
-int get_disp_mode() { return disp_mode; }
+int get_disp_mode() { 
+	return disp_mode; 
+}
 
 static void toggle_disp_mode_menu(void *priv, int delta) {
-    if (!disp_profiles_0) menu_toggle_submenu();
-    else toggle_disp_mode();
+    if (!disp_profiles_0) {
+    	menu_toggle_submenu();
+    } else {
+    	toggle_disp_mode();
+    }
 }
 
-int toggle_disp_mode()
-{
+int toggle_disp_mode() {
     update_disp_mode_bits_from_params();
     idle_wakeup_reset_counters(-3);
     disp_mode = MOD(disp_mode + 1, disp_profiles_0 + 1);
     BMP_LOCK( do_disp_mode_change(); )
     //~ menu_set_dirty();
-    return disp_mode == 0;
+    return (disp_mode == 0);
+}
+
+static void do_disp_mode_change() {
+    if (gui_menu_shown()) { 
+        update_disp_mode_params_from_bits();         
+    } else {    
+		display_on();
+		bmp_on();
+		clrscr();
+		idle_globaldraw_dis();
+		//~ redraw();
+		bmp_printf(SHADOW_FONT(FONT_LARGE), 50, 50, "Display preset: %d", disp_mode);
+		msleep(250);
+		idle_globaldraw_en();
+		update_disp_mode_params_from_bits();
+		redraw();
+    }
 }
-static void do_disp_mode_change()
-{
-    if (gui_menu_shown()) 
-    { 
-        update_disp_mode_params_from_bits(); 
-        return; 
+
+int handle_disp_preset_key(struct event * event) {
+    /*the INFO key may be also used for enabling powersaving right away
+      if display presets are off: pressing INFO will go to powersave (if any of those modes are enabled)
+      if display presets are on: powersave will act somewhat like an extra display preset
+    */
+    int value = 0;
+     
+    if (event->param == BGMT_INFO) {
+        if (!disp_profiles_0) {
+        	value = handle_powersave_key(event);
+		} else {
+
+		    if ((!lv && !LV_PAUSED) || IS_FAKE(event) || gui_menu_shown()) {        	
+		    	value = 1;
+			} else {
+				
+				if (idle_is_powersave_enabled_on_info_disp_key()) {
+				    if (disp_mode == disp_profiles_0 && !idle_is_powersave_active()) {
+				    	value = handle_powersave_key(event);				       
+				    } else {
+				        toggle_disp_mode(); // and wake up from powersave
+				    }
+				} else {
+				    toggle_disp_mode();
+				}								
+			}
+		}
     }
     
-    display_on();
-    bmp_on();
-    clrscr();
-    idle_globaldraw_dis();
-    //~ redraw();
-    bmp_printf(SHADOW_FONT(FONT_LARGE), 50, 50, "Display preset: %d", disp_mode);
-    msleep(250);
-    idle_globaldraw_en();
-    update_disp_mode_params_from_bits();
-    redraw();
-}
-
-int handle_disp_preset_key(struct event * event)
-{
-    // the INFO key may be also used for enabling powersaving right away
-    // if display presets are off: pressing INFO will go to powersave (if any of those modes are enabled)
-    // if display presets are on: powersave will act somewhat like an extra display preset
-    
-    if (event->param == BGMT_INFO)
-    {
-        if (!disp_profiles_0)
-            return handle_powersave_key(event);
-
-        if (!lv && !LV_PAUSED) return 1;
-        if (IS_FAKE(event)) return 1;
-        if (gui_menu_shown()) return 1;
-        
-        if (idle_is_powersave_enabled_on_info_disp_key())
-        {
-            if (disp_mode == disp_profiles_0 && !idle_is_powersave_active())
-                return handle_powersave_key(event);
-            else
-                toggle_disp_mode(); // and wake up from powersave
-        }
-        else
-        {
-            toggle_disp_mode();
-        }
-        return 0;
-    }
-    return 1;
+    value = 1;
+    return value;
 }
 
 #ifdef FEATURE_OVERLAYS_IN_PLAYBACK_MODE
-static int overlays_playback_displayed = 0;
-
-static void overlays_playback_clear()
-{
-    if (overlays_playback_displayed)
-    {
-        clrscr();
-        digic_zebra_cleanup();
-        redraw();
-        overlays_playback_displayed = 0;
-    }
-}
-
-/* called from GUI handler */
-static void overlays_playback_toggle()
-{
-    if (overlays_playback_running)
-        return;
-    
-    if (!overlays_playback_displayed)
-    {
-        /* this may take about 1 second, so let's run it outside GuiMainTask */
-        overlays_playback_running = 1;
-        task_create("lv_playback", 0x1a, 0x8000, draw_overlays_playback, 0);
-        overlays_playback_displayed = 1;
-    }
-    else
-    {
-        overlays_playback_clear();
-    }
-}
-
-int handle_overlays_playback(struct event * event)
-{
-    // enable LiveV stuff in Play mode
-    if (PLAY_OR_QR_MODE)
-    {
-        switch(event->param)
-        {
-#if defined(BTN_ZEBRAS_FOR_PLAYBACK) && defined(BTN_ZEBRAS_FOR_PLAYBACK_NAME)
-            case BTN_ZEBRAS_FOR_PLAYBACK:
-                /* used in PLAY mode (user pressed button to toggle overlays) */
-                overlays_playback_toggle();
-                return 0;
+	static int overlays_playback_displayed = 0;
+
+	static void overlays_playback_clear() {
+		if (overlays_playback_displayed) {
+		    clrscr();
+		    digic_zebra_cleanup();
+		    redraw();
+		    overlays_playback_displayed = 0;
+		}
+	}
+
+	/* called from GUI handler */
+	static void overlays_playback_toggle() {
+		if (!overlays_playback_running) {                
+			if (!overlays_playback_displayed) {
+				/* this may take about 1 second, so let's run it outside GuiMainTask */
+				overlays_playback_running = 1;
+				task_create("lv_playback", 0x1a, 0x8000, draw_overlays_playback, 0);
+				overlays_playback_displayed = 1;
+			} else {
+				overlays_playback_clear();
+			}
+		}
+	}
+
+	int handle_overlays_playback(struct event * event) {
+		int value=0; 
+		// enable LiveV stuff in Play mode
+		if (PLAY_OR_QR_MODE) {
+		    switch(event->param) {
+				#if defined(BTN_ZEBRAS_FOR_PLAYBACK) && defined(BTN_ZEBRAS_FOR_PLAYBACK_NAME)
+				    case BTN_ZEBRAS_FOR_PLAYBACK:
+				        /* used in PLAY mode (user pressed button to toggle overlays) */
+				        overlays_playback_toggle();                
+				        break;
+				#endif
+		        case MLEV_TRIGGER_ZEBRAS_FOR_PLAYBACK:
+		            /* used in QuickReview mode - always show the overlays, no toggle */
+		            overlays_playback_displayed = 0;
+		            overlays_playback_toggle();                
+		            break;
+		    }
+		    
+		    if (event->param == GMT_OLC_INFO_CHANGED) {
+		    	value=1;
+			} else {
+			
+				#ifdef GMT_GUICMD_PRESS_BUTTON_SOMETHING
+					if (event->param == GMT_GUICMD_PRESS_BUTTON_SOMETHING) {
+						value=1;
+					} else {
+				#endif
+				
+						/* some button pressed in play mode, while ML overlays are active? clear them */
+						overlays_playback_clear();
+				#ifdef GMT_GUICMD_PRESS_BUTTON_SOMETHING
+					}
+				#endif
+			
+			}		
+		} else {
+		    /* got out of play mode? ML overlays are for sure no longer active */
+		    overlays_playback_displayed = 0;
+		}
+		value=1;
+		return value; 
+	}
 #endif
-            case MLEV_TRIGGER_ZEBRAS_FOR_PLAYBACK:
-                /* used in QuickReview mode - always show the overlays, no toggle */
-                overlays_playback_displayed = 0;
-                overlays_playback_toggle();
-                return 0;
-        }
-        
-        if (event->param == GMT_OLC_INFO_CHANGED)
-            return 1;
-
-        #ifdef GMT_GUICMD_PRESS_BUTTON_SOMETHING
-        else if (event->param == GMT_GUICMD_PRESS_BUTTON_SOMETHING)
-            return 1;
-        #endif
-
-        else
-        {
-            /* some button pressed in play mode, while ML overlays are active? clear them */
-            overlays_playback_clear();
-        }
-    }
-    else
-    {
-        /* got out of play mode? ML overlays are for sure no longer active */
-        overlays_playback_displayed = 0;
-    }
-    return 1;
-}
-#endif
-
-static void zebra_init()
-{
+
+static void zebra_init() {
     precompute_yuv2rgb();
     menu_add( "Overlay", zebra_menus, COUNT(zebra_menus) );
     menu_add( "Debug", livev_dbg_menus, COUNT(livev_dbg_menus) );
     //~ menu_add( "Movie", movie_menus, COUNT(movie_menus) );
     //~ menu_add( "Config", cfg_menus, COUNT(cfg_menus) );
     #ifdef FEATURE_CROPMARKS
-    menu_add( "Overlay", cropmarks_menu, COUNT(cropmarks_menu) );
+    	menu_add( "Overlay", cropmarks_menu, COUNT(cropmarks_menu) );
     #endif
 }
 
 INIT_FUNC(__FILE__, zebra_init);
 
 
-static void make_overlay()
-{
+static void make_overlay() {
     //~ draw_cropmark_area();
     msleep(1000);
     //~ bvram_mirror_init();
@@ -4480,99 +4480,91 @@
 
     struct vram_info * vram = get_yuv422_vram();
     uint8_t * const lvram = vram->vram;
-    if (!lvram) return;
-
-    uint8_t * const bvram = bmp_vram();
-    if (!bvram) return;
-
-    // difficulty: in play mode, image buffer may have different size/position than in LiveView
-    // => normalized xn and yn will fix this
-    for (int yn = 0; yn < 480; yn++)
-    {
-        int y = N2BM_Y(yn);
-        //~ int k;
-        uint16_t * const v_row = (uint16_t*)( lvram        + BM2LV_R(y)); // 1 pixel
-        uint8_t  * const b_row = (uint8_t*) ( bvram        + BM_R(y));    // 1 pixel
-        uint8_t  * const m_row = (uint8_t*) ( bvram_mirror + BM_R(yn));    // 1 pixel
-        uint16_t* lvp; // that's a moving pointer through lv vram
-        uint8_t* bp;   // through bmp vram
-        uint8_t* mp;   // through bmp vram mirror
-        for (int xn = 0; xn < 720; xn++)
-        {
-            int x = N2BM_X(xn);
-            lvp = v_row + BM2LV_X(x);
-            bp = b_row + x;
-            mp = m_row + xn;
-            *bp = *mp = ((*lvp) * 41 >> 16) + 38;
-        }
-    }
-    FILE* f = FIO_CreateFile("ML/DATA/overlay.dat");
-    if (f)
-    {
-        FIO_WriteFile( f, (const void *) bvram_mirror, BVRAM_MIRROR_SIZE);
-        FIO_CloseFile(f);
-        bmp_printf(FONT_MED, 0, 0, "Overlay saved.  ");
-    }
-    else
-    {
-        bmp_printf(FONT_MED, 0, 0, "Overlay error.  ");
-    }
-    msleep(1000);
+    if (lvram) {			
+		uint8_t * const bvram = bmp_vram();
+		if (bvram) {			
+			// difficulty: in play mode, image buffer may have different size/position than in LiveView
+			// => normalized xn and yn will fix this
+			for (int yn = 0; yn < 480; yn++) {
+				int y = N2BM_Y(yn);
+				//~ int k;
+				uint16_t * const v_row = (uint16_t*)( lvram        + BM2LV_R(y)); // 1 pixel
+				uint8_t  * const b_row = (uint8_t*) ( bvram        + BM_R(y));    // 1 pixel
+				uint8_t  * const m_row = (uint8_t*) ( bvram_mirror + BM_R(yn));    // 1 pixel
+				uint16_t* lvp; // that's a moving pointer through lv vram
+				uint8_t* bp;   // through bmp vram
+				uint8_t* mp;   // through bmp vram mirror
+				for (int xn = 0; xn < 720; xn++) {
+				    int x = N2BM_X(xn);
+				    lvp = v_row + BM2LV_X(x);
+				    bp = b_row + x;
+				    mp = m_row + xn;
+				    *bp = *mp = ((*lvp) * 41 >> 16) + 38;
+				}
+			}
+			FILE* f = FIO_CreateFile("ML/DATA/overlay.dat");
+			if (f) {
+				FIO_WriteFile( f, (const void *) bvram_mirror, BVRAM_MIRROR_SIZE);
+				FIO_CloseFile(f);
+				bmp_printf(FONT_MED, 0, 0, "Overlay saved.  ");
+			} else {
+				bmp_printf(FONT_MED, 0, 0, "Overlay error.  ");
+			}
+			msleep(1000);
+		}
+	}
 }
 
-static void show_overlay()
-{
+static void show_overlay() {
     //~ bvram_mirror_init();
     //~ struct vram_info * vram = get_yuv422_vram();
     //~ uint8_t * const lvram = vram->vram;
     //~ int lvpitch = YUV422_LV_PITCH;
     get_yuv422_vram();
     uint8_t * const bvram = bmp_vram_real();
-    if (!bvram) return;
-    
-    clrscr();
-
-    int size = 0;
-    void * tmp = read_entire_file("ML/DATA/overlay.dat", &size);
-    if (tmp)
-    {
-        ASSERT(size == BVRAM_MIRROR_SIZE);
-        memcpy(bvram_mirror, tmp, BVRAM_MIRROR_SIZE);
-        free(tmp); tmp = NULL;
-    }
-
-    for (int y = os.y0; y < os.y_max; y++)
-    {
-        int yn = BM2N_Y(y);
-        int ym = yn - (int)transparent_overlay_offy; // normalized with offset applied
-        //~ int k;
-        //~ uint16_t * const v_row = (uint16_t*)( lvram + y * lvpitch );        // 1 pixel
-        uint8_t * const b_row = (uint8_t*)( bvram + y * BMPPITCH);          // 1 pixel
-        uint8_t * const m_row = (uint8_t*)( bvram_mirror + ym * BMPPITCH);   // 1 pixel
-        uint8_t* bp;  // through bmp vram
-        uint8_t* mp;  //through bmp vram mirror
-        if (ym < 0 || ym > 480) continue;
-        //~ int offm = 0;
-        //~ int offb = 0;
-        //~ if (transparent_overlay == 2) offm = 720/2;
-        //~ if (transparent_overlay == 3) offb = 720/2;
-        for (int x = os.x0; x < os.x_max; x++)
-        {
-            int xn = BM2N_X(x);
-            int xm = xn - (int)transparent_overlay_offx;
-            bp = b_row + x;
-            mp = m_row + xm;
-            if (((x+y) % 2) && xm >= 0 && xm <= 720)
-                *bp = *mp;
-        }
-    }
-    
-    bvram_mirror_clear();
-    afframe_clr_dirty();
+    if (bvram) {					
+		clrscr();
+
+		int size = 0;
+		void * tmp = read_entire_file("ML/DATA/overlay.dat", &size);
+		if (tmp) {
+		    ASSERT(size == BVRAM_MIRROR_SIZE);
+		    memcpy(bvram_mirror, tmp, BVRAM_MIRROR_SIZE);
+		    free(tmp); tmp = NULL;
+		}
+
+		for (int y = os.y0; y < os.y_max; y++) {
+		    int yn = BM2N_Y(y);
+		    int ym = yn - (int)transparent_overlay_offy; // normalized with offset applied
+		    //~ int k;
+		    //~ uint16_t * const v_row = (uint16_t*)( lvram + y * lvpitch );        // 1 pixel
+		    uint8_t * const b_row = (uint8_t*)( bvram + y * BMPPITCH);          // 1 pixel
+		    uint8_t * const m_row = (uint8_t*)( bvram_mirror + ym * BMPPITCH);   // 1 pixel
+		    uint8_t* bp;  // through bmp vram
+		    uint8_t* mp;  //through bmp vram mirror
+		    if (ym < 0 || ym > 480) {		    	
+				//~ int offm = 0;
+				//~ int offb = 0;
+				//~ if (transparent_overlay == 2) offm = 720/2;
+				//~ if (transparent_overlay == 3) offb = 720/2;
+				for (int x = os.x0; x < os.x_max; x++) {
+				    int xn = BM2N_X(x);
+				    int xm = xn - (int)transparent_overlay_offx;
+				    bp = b_row + x;
+				    mp = m_row + xm;
+				    if (((x+y) % 2) && xm >= 0 && xm <= 720) {
+				        *bp = *mp;
+				    }
+				}
+			}
+		}
+		
+		bvram_mirror_clear();
+		afframe_clr_dirty();
+	}
 }
 
-static void transparent_overlay_from_play()
-{
+static void transparent_overlay_from_play() {
     /* go to play mode if not already there */
     enter_play_mode();
     
@@ -4585,12 +4577,13 @@
     /* the overlay will now be displayed from cropmarks.c */
 }
 
-PROP_HANDLER(PROP_LV_ACTION)
-{
+PROP_HANDLER(PROP_LV_ACTION) {
     zoom_overlay_triggered_by_focus_ring_countdown = 0;
     
     idle_globaldraw_disable = 0;
-    if (buf[0] == 0) lv_paused = 0;
+    if (buf[0] == 0) {
+    	lv_paused = 0;
+    }
     
     #ifdef FEATURE_EXPO_OVERRIDE
     bv_auto_update();
@@ -4601,8 +4594,7 @@
     #endif
 }
 
-void peaking_benchmark()
-{
+void peaking_benchmark() {
     int old_lv = lv;
     int old_peaking = focus_peaking;
     focus_peaking = 1;
@@ -4611,8 +4603,7 @@
     msleep(2000);
     int a = get_seconds_clock();
     lv = 1; // lie, to force using the liveview algorithm which is relevant for benchmarking
-    for (int i = 0; i < 1000; i++)
-    {
+    for (int i = 0; i < 1000; i++) {
         draw_zebra_and_focus(0,1);
     }
     int b = get_seconds_clock();




